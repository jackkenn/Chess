package game.pieces;

import java.util.ArrayList;
import game.Board;
import game.Board.Cord;
import game.Board.PieceType;
import game.Board.Spot;
import game.Player;

public abstract class Piece implements Cloneable {
	protected Player player;
	protected Spot spot;
	protected Board board;
	public ArrayList<Spot> possibleMoves = new ArrayList<Spot>();
	public Pawn enPassant = null;
	public boolean moved = false;
	public ArrayList<Spot[]> pinned = new ArrayList<Spot[]>();
	public ArrayList<Spot[]> pinning = new ArrayList<Spot[]>();

	public Piece(Player givenPlayer, Spot givenSpot, Board givenBoard) {
		player = givenPlayer;
		spot = givenSpot;
		board = givenBoard;
		player.pieces.add(this);
	}

	public Piece(Piece givenPiece) {
		player = givenPiece.player;
		spot = givenPiece.spot;
		board = givenPiece.board;
	}
	
	public Piece clone(Player givenPlayer, Spot givenSpot, Board givenBoard) throws CloneNotSupportedException {
		Piece clone = (Piece) super.clone();
		clone.player = givenPlayer;
		clone.spot = givenSpot;
		clone.board = givenBoard;
		givenPlayer.pieces.add(clone);
		clone.moved = moved;
		givenSpot.setPiece(clone);
		return clone;
	}

	public void delete() { //likely not needed
		player.pieces.remove(this);
		removeMoves();
		spot.piece = new Empty(board.empty, spot, board);
	}

	public void move(Spot next) {
		next.piece.delete();
		spot.piece = new Empty(board.empty, spot, board);
		spot = next;
		spot.piece = this;
		moved = true;
	}

	public Spot getSpot() {
		return spot;
	}

	public Piece clone(Spot givenSpot) {
		Piece piece = null;
		try {
			piece = (Piece) super.clone();
			piece.spot = givenSpot;
			piece.player.pieces.add(piece);

		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
		}
		return piece;
	}

	public Player getPlayer() {
		return player;
	}

	public String[] getMovesList() {
		getMoves();
		String[] str = new String[possibleMoves.size()];
		for (int i = 0; i < possibleMoves.size(); i++) {
			str[i] = possibleMoves.get(i).cord.toString();
		}
		return str;
	}

	public void addMoves() {
		removeMoves();
		getMoves();
		for (Spot s : possibleMoves) {
			s.possiblePieces.add(this);
		}
	}

	public void removeMoves() {
		for (Spot s : possibleMoves) {
			s.possiblePieces.remove(this);
		}
		for(Spot s[] : pinning) {
			s[0].piece.pinned.remove(s[0].piece.getPinned(spot));
			if(s.length == 2) {
				s[1].piece.pinned.remove(s[1].piece.getPinned(spot));
			}
		}
		pinning.clear();
		for(Spot s[] : pinned) {
			
		}
	}
	
	public int getPinned(Spot pinnedBy) {
		for(int i = 0; i<pinned.size(); i++) {
			if(pinned.get(i)[0].equals(pinnedBy)) {
				return i;
			}
			if(pinned.get(i)[1].equals(pinnedBy)) {
				return i;
			}
			if(pinned.get(i).length == 3) {
				if(pinned.get(i)[2].equals(pinnedBy)) {
					return i;
				}
			}
		}
		return -1;
	}
	
	public void addPinned(Spot pinnedBy, Spot pinned, Spot pinnedTo) {
		if(pinnedTo == null) {
			pinnedBy.piece.pinning.add(new Spot[] {pinned});
			pinned.piece.pinned.add(new Spot[] {pinnedBy, pinned});
		} else {
			pinnedBy.piece.pinning.add(new Spot[] {pinned, pinnedTo});
			pinned.piece.pinned.add(new Spot[] {pinnedBy, pinned, pinnedTo});
			pinnedTo.piece.pinned.add(new Spot[] {pinnedBy, pinned, pinnedTo});
		}
	}
	
	public void addPinned(Spot pinnedBy, Spot pinned) {
		addPinned(pinnedBy, pinned, null);
	}

	public abstract PieceType getType();

	public abstract String toString();

	public abstract ArrayList<Spot> getMoves();

}
