package bots;

import java.util.Comparator;

import game.Board;
import game.Board.Spot;
import game.GameLoop;
import game.Player;
import game.pieces.Piece;

public class UltraInstictStockFish extends AI {
	private int turn = 0;
	private Spot[] focus; // point of attack

	private final int pieceWeight; // Material value * this
	private final int spotWeight; // where it is
	private final int movesWeight; // where it can go
	private final int pinningWeight; // pinning
	private final int protectWeight; // protecting
	private final int attackingWeight; // can capture
	private final int attackedWeight; // can be captured
	private final int selfPreference; // our board value * this
	private final int checkWeight; // putting opp in check

	public UltraInstictStockFish(GameLoop game, boolean isWhite, Long seed) {
		super(game, isWhite, seed);
		// TODO Auto-generated constructor stub
	}

	@Override
	public boolean move() {
		// TODO Auto-generated method stub
		return false;
	}

	private int valueOfBoard(Player player) {
		int matValue = 0;
		int posValue = 0;
		for (Piece p : player.pieces) {
			if (p.getType() != Board.PieceType.KING) {
				matValue += p.getValue();
			}
			for (Piece[] piece : p.pinning) {
				if (piece[0].getPlayer().equals(self.opponent)) {
					if(piece[0].getType() == Board.PieceType.KING) {
						posValue += checkWeight;
					} else {
						posValue += attacking(piece[0]) * attackingWeight;
					}
				} else {
					if(piece[0].getType() != Board.PieceType.KING) {
						posValue += attacking(piece[0]) * protectWeight;
					}
				}
			}

		}
		return -1;
	}

	private int attacking(Piece piece) { // does not check legal moves
		int attackers = 0;
		int deffenders = 0;
		Piece aList[] = new Piece[piece.pinned.size() - 1];
		Piece dList[] = new Piece[piece.pinned.size() - 1];
		for (Piece[] p : piece.pinned) {
			if (p[0].getPlayer().equals(piece.getPlayer())) {
				dList[deffenders] = p[0];
				deffenders++;
			} else {
				aList[attackers] = p[0];
				attackers++;
			}
		}
		Comparator<Object> comp = new Comparator<Object>() {

			@Override
			public int compare(Object o1, Object o2) {
				return ((Piece) o1).getValue() - ((Piece) o2).getValue();
			}

		};
		sort(aList, comp, attackers);
		sort(dList, comp, deffenders);
		int value = piece.getValue();
		if(deffenders > 0) {
			int values[] = new int[piece.pinned.size()];
			values[0] = value;
			int i = 0;
			int j = 1;
			while (i <= Math.min(attackers, deffenders)) {
				value -= aList[i].getValue();
				values[j] = value;
				j++;
				if(i < attackers) {
					value += dList[i].getValue();
					values[j] = value;
					j++;
				}
				i++;
			}
			return bestCapture(values, true, j);
		}
		return value;
	}
	
	private int bestCapture(int arr[], boolean findLow, int Endindex) {
		int index = 0;
		if(findLow) {
			for(int i = 0; i < Endindex / 2; i+=2) {
				if(arr[i] < arr[index]) {
					index = i;
				}
			}
			return bestCapture(arr, !findLow, index);
		} else {
			for(int i = 1; i < Endindex / 2; i+=2) {
				if(arr[i] > arr[index]) {
					index = i;
				}
			}
			return index;
		}
	}

}
